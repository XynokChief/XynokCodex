{Scope}
using System;
using Sirenix.OdinInspector;
using UnityEngine;
using XynokConvention;
using XynokConvention.Procedural;
using XynokConvention.Enums;
using XynokEntity.Enums;
using XynokConvention.APIs;
using XynokSourceGenerator.Entities.APIs;
using XynokSourceGenerator.Entities.Data;


namespace XynokSourceGenerator.Entities 
{
    /// <summary>
    /// {EntityName} base class ability
    /// </summary>
    [Serializable]
    public abstract class A{EntityName}Ability: I{EntityName}Ability
    {
        protected I{EntityName} owner;
        
        [FoldoutGroup(ConventionKey.Settings)] [SerializeField] [LabelWidth(130)] [Space(10)] protected UpdateMode updateMode = UpdateMode.Update;
        [Tooltip("Khi nào thì các validator sẽ được kiểm tra để xem ability có thể được thực thi hay không")]
        [FoldoutGroup(ConventionKey.Settings)] [SerializeField] [LabelWidth(130)] protected AbilityExecuteValidatorType executeValidator = AbilityExecuteValidatorType.WhenOwnerStateChanged;
        [FoldoutGroup(ConventionKey.Settings)] [ShowIf(nameof(executeValidator), AbilityExecuteValidatorType.Custom)] [SerializeReference] [HideLabel] protected I{EntityName}DataValidator customValidator;
        [FoldoutGroup(ConventionKey.Settings)] [HideIf(nameof(executeValidator), AbilityExecuteValidatorType.Custom)] [SerializeField] [HideLabel] protected CharacterDataValidatorContainer validator;
        
        private bool _canExecute;
        private Action _onDispose;
    
        public void SetDependency(I{EntityName} dependency)
        {
            Dispose();
            if(dependency == null)
            {
             Debug.LogError($"[{GetType().Name}]: dependency is null");
             return;
            }
            owner = dependency;
            InitValidators();
            OnStateOwnerChanged(owner.CurrentState.Value);
            owner.CurrentState.OnChanged += OnStateOwnerChanged;
            Init();
            TimeCycle.Instance.AddInvoker(Execute, updateMode);
        }
        
        public void Dispose()
        {
            if(owner != null) owner.CurrentState.OnChanged -= OnStateOwnerChanged;
            TimeCycle.Instance.RemoveInvoker(Execute, updateMode);
            _onDispose?.Invoke();
            _onDispose = default;
            OnDispose();
        }
        
        public void Execute()
        {
            if(!IsValidated()) return;
            OnExecute();
        }
        
        void InitValidators()
        {
            validator.SetDependency(owner);
            _onDispose += validator.Dispose;
        }

        void OnStateOwnerChanged({EntityName}StateFlag state)
        {
            _canExecute = validator.IsValid();
        }
        
        bool IsValidated()
        {
            if(executeValidator == AbilityExecuteValidatorType.WhenOwnerStateChanged) return _canExecute;
            if(executeValidator == AbilityExecuteValidatorType.Always) return validator.IsValid();
            return true;
        }
        
        protected abstract void Init();
        protected abstract void OnExecute();
        public abstract void Reset();
        protected abstract void OnDispose();
      
    }

}

{Body}